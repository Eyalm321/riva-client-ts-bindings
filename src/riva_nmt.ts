// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.28.0
// source: riva/proto/riva_nmt.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { StreamingRecognitionConfig, StreamingRecognitionResult } from "./riva_asr";
import { AudioEncoding, audioEncodingFromJSON, audioEncodingToJSON } from "./riva_audio";
import { RequestId } from "./riva_common";
import { SynthesizeSpeechResponse } from "./riva_tts";

export const protobufPackage = "nvidia.riva.nmt";

/** Configuration for Translate S2S.  reuse existing protos from other services. */
export interface StreamingTranslateSpeechToSpeechConfig {
  /** From riva_asr.proto */
  asrConfig: StreamingRecognitionConfig | undefined;
  ttsConfig: SynthesizeSpeechConfig | undefined;
  translationConfig: TranslationConfig | undefined;
}

/**
 * Streaming translate speech to speech used to configure the entire pipline for
 * speech translation.  This can be be backed by a cascade of ASR, NMT, TTS
 * models or an end to end model
 */
export interface StreamingTranslateSpeechToSpeechRequest {
  config?: StreamingTranslateSpeechToSpeechConfig | undefined;
  audioContent?:
    | Uint8Array
    | undefined;
  /**
   * The ID to be associated with the request. If provided, this will be
   * returned in the corresponding response.
   */
  id: RequestId | undefined;
}

export interface TranslationConfig {
  /** BCP-47 "en-US" */
  sourceLanguageCode: string;
  targetLanguageCode: string;
  modelName: string;
}

export interface SynthesizeSpeechConfig {
  encoding: AudioEncoding;
  sampleRateHz: number;
  voiceName: string;
  languageCode: string;
  prosodyRate: string;
  prosodyPitch: string;
  prosodyVolume: string;
}

export interface StreamingTranslateSpeechToSpeechResponse {
  /**
   * Contains speech responses, the last response sends an empty buffer to mark
   * the end of stream.
   */
  speech:
    | SynthesizeSpeechResponse
    | undefined;
  /** The ID associated with the request */
  id: RequestId | undefined;
}

export interface StreamingTranslateSpeechToTextRequest {
  config?: StreamingTranslateSpeechToTextConfig | undefined;
  audioContent?:
    | Uint8Array
    | undefined;
  /**
   * The ID to be associated with the request. If provided, this will be
   * returned in the corresponding response.
   */
  id: RequestId | undefined;
}

export interface StreamingTranslateSpeechToTextResponse {
  /** from riva_asr.proto */
  results: StreamingRecognitionResult[];
  /** The ID associated with the request */
  id: RequestId | undefined;
}

export interface StreamingTranslateSpeechToTextConfig {
  /** existing ASR config */
  asrConfig: StreamingRecognitionConfig | undefined;
  translationConfig: TranslationConfig | undefined;
}

/**
 * request for synchronous translation of each text in texts.
 * Available languages can be queried using ListSupportLanguagePairs RPC.
 * source and target languages must be specified, are currently two character
 * ISO codes, this will likely change to BCP-47 inline with other Riva Services
 * for GA.
 */
export interface TranslateTextRequest {
  texts: string[];
  model: string;
  sourceLanguage: string;
  targetLanguage: string;
  /**
   * The ID to be associated with the request. If provided, this will be
   * returned in the corresponding response.
   */
  id: RequestId | undefined;
}

/**
 * contains a single translation, collecting into the translate text response
 * Includes the target language code, since with multi lingual models there are
 * multiple possibilities.
 */
export interface Translation {
  text: string;
  language: string;
}

/**
 * Translations are returned as text:language pairs.  These are 1:1 for the
 * passed in 'texts' from the request.
 */
export interface TranslateTextResponse {
  translations: Translation[];
  /** The ID associated with the request */
  id: RequestId | undefined;
}

/**
 * Returns a map of model names to its source and target language pairs.
 * Can specificy a specific model name to retrieve only its language pairs.
 */
export interface AvailableLanguageRequest {
  /** If empty returns all available languages. */
  model: string;
}

/**
 * Language pairs are the sets of src to tgt languages available per model.
 * languages contains all the model_name -> Language pair
 */
export interface AvailableLanguageResponse {
  languages: { [key: string]: AvailableLanguageResponse_LanguagePair };
}

export interface AvailableLanguageResponse_LanguagePair {
  srcLang: string[];
  tgtLang: string[];
}

export interface AvailableLanguageResponse_LanguagesEntry {
  key: string;
  value: AvailableLanguageResponse_LanguagePair | undefined;
}

function createBaseStreamingTranslateSpeechToSpeechConfig(): StreamingTranslateSpeechToSpeechConfig {
  return { asrConfig: undefined, ttsConfig: undefined, translationConfig: undefined };
}

export const StreamingTranslateSpeechToSpeechConfig = {
  encode(message: StreamingTranslateSpeechToSpeechConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asrConfig !== undefined) {
      StreamingRecognitionConfig.encode(message.asrConfig, writer.uint32(10).fork()).join();
    }
    if (message.ttsConfig !== undefined) {
      SynthesizeSpeechConfig.encode(message.ttsConfig, writer.uint32(18).fork()).join();
    }
    if (message.translationConfig !== undefined) {
      TranslationConfig.encode(message.translationConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToSpeechConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToSpeechConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asrConfig = StreamingRecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ttsConfig = SynthesizeSpeechConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.translationConfig = TranslationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToSpeechConfig {
    return {
      asrConfig: isSet(object.asrConfig) ? StreamingRecognitionConfig.fromJSON(object.asrConfig) : undefined,
      ttsConfig: isSet(object.ttsConfig) ? SynthesizeSpeechConfig.fromJSON(object.ttsConfig) : undefined,
      translationConfig: isSet(object.translationConfig)
        ? TranslationConfig.fromJSON(object.translationConfig)
        : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToSpeechConfig): unknown {
    const obj: any = {};
    if (message.asrConfig !== undefined) {
      obj.asrConfig = StreamingRecognitionConfig.toJSON(message.asrConfig);
    }
    if (message.ttsConfig !== undefined) {
      obj.ttsConfig = SynthesizeSpeechConfig.toJSON(message.ttsConfig);
    }
    if (message.translationConfig !== undefined) {
      obj.translationConfig = TranslationConfig.toJSON(message.translationConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechConfig>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToSpeechConfig {
    return StreamingTranslateSpeechToSpeechConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechConfig>, I>>(
    object: I,
  ): StreamingTranslateSpeechToSpeechConfig {
    const message = createBaseStreamingTranslateSpeechToSpeechConfig();
    message.asrConfig = (object.asrConfig !== undefined && object.asrConfig !== null)
      ? StreamingRecognitionConfig.fromPartial(object.asrConfig)
      : undefined;
    message.ttsConfig = (object.ttsConfig !== undefined && object.ttsConfig !== null)
      ? SynthesizeSpeechConfig.fromPartial(object.ttsConfig)
      : undefined;
    message.translationConfig = (object.translationConfig !== undefined && object.translationConfig !== null)
      ? TranslationConfig.fromPartial(object.translationConfig)
      : undefined;
    return message;
  },
};

function createBaseStreamingTranslateSpeechToSpeechRequest(): StreamingTranslateSpeechToSpeechRequest {
  return { config: undefined, audioContent: undefined, id: undefined };
}

export const StreamingTranslateSpeechToSpeechRequest = {
  encode(message: StreamingTranslateSpeechToSpeechRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      StreamingTranslateSpeechToSpeechConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audioContent !== undefined) {
      writer.uint32(18).bytes(message.audioContent);
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToSpeechRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToSpeechRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = StreamingTranslateSpeechToSpeechConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioContent = reader.bytes();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToSpeechRequest {
    return {
      config: isSet(object.config) ? StreamingTranslateSpeechToSpeechConfig.fromJSON(object.config) : undefined,
      audioContent: isSet(object.audioContent) ? bytesFromBase64(object.audioContent) : undefined,
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToSpeechRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = StreamingTranslateSpeechToSpeechConfig.toJSON(message.config);
    }
    if (message.audioContent !== undefined) {
      obj.audioContent = base64FromBytes(message.audioContent);
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechRequest>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToSpeechRequest {
    return StreamingTranslateSpeechToSpeechRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechRequest>, I>>(
    object: I,
  ): StreamingTranslateSpeechToSpeechRequest {
    const message = createBaseStreamingTranslateSpeechToSpeechRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? StreamingTranslateSpeechToSpeechConfig.fromPartial(object.config)
      : undefined;
    message.audioContent = object.audioContent ?? undefined;
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseTranslationConfig(): TranslationConfig {
  return { sourceLanguageCode: "", targetLanguageCode: "", modelName: "" };
}

export const TranslationConfig = {
  encode(message: TranslationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceLanguageCode !== "") {
      writer.uint32(10).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(18).string(message.targetLanguageCode);
    }
    if (message.modelName !== "") {
      writer.uint32(26).string(message.modelName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.modelName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslationConfig {
    return {
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
    };
  },

  toJSON(message: TranslationConfig): unknown {
    const obj: any = {};
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranslationConfig>, I>>(base?: I): TranslationConfig {
    return TranslationConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranslationConfig>, I>>(object: I): TranslationConfig {
    const message = createBaseTranslationConfig();
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.modelName = object.modelName ?? "";
    return message;
  },
};

function createBaseSynthesizeSpeechConfig(): SynthesizeSpeechConfig {
  return {
    encoding: 0,
    sampleRateHz: 0,
    voiceName: "",
    languageCode: "",
    prosodyRate: "",
    prosodyPitch: "",
    prosodyVolume: "",
  };
}

export const SynthesizeSpeechConfig = {
  encode(message: SynthesizeSpeechConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encoding !== 0) {
      writer.uint32(8).int32(message.encoding);
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(16).int32(message.sampleRateHz);
    }
    if (message.voiceName !== "") {
      writer.uint32(26).string(message.voiceName);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (message.prosodyRate !== "") {
      writer.uint32(42).string(message.prosodyRate);
    }
    if (message.prosodyPitch !== "") {
      writer.uint32(50).string(message.prosodyPitch);
    }
    if (message.prosodyVolume !== "") {
      writer.uint32(58).string(message.prosodyVolume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SynthesizeSpeechConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSynthesizeSpeechConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.encoding = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sampleRateHz = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.voiceName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.prosodyRate = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.prosodyPitch = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.prosodyVolume = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SynthesizeSpeechConfig {
    return {
      encoding: isSet(object.encoding) ? audioEncodingFromJSON(object.encoding) : 0,
      sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
      voiceName: isSet(object.voiceName) ? globalThis.String(object.voiceName) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      prosodyRate: isSet(object.prosodyRate) ? globalThis.String(object.prosodyRate) : "",
      prosodyPitch: isSet(object.prosodyPitch) ? globalThis.String(object.prosodyPitch) : "",
      prosodyVolume: isSet(object.prosodyVolume) ? globalThis.String(object.prosodyVolume) : "",
    };
  },

  toJSON(message: SynthesizeSpeechConfig): unknown {
    const obj: any = {};
    if (message.encoding !== 0) {
      obj.encoding = audioEncodingToJSON(message.encoding);
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = Math.round(message.sampleRateHz);
    }
    if (message.voiceName !== "") {
      obj.voiceName = message.voiceName;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.prosodyRate !== "") {
      obj.prosodyRate = message.prosodyRate;
    }
    if (message.prosodyPitch !== "") {
      obj.prosodyPitch = message.prosodyPitch;
    }
    if (message.prosodyVolume !== "") {
      obj.prosodyVolume = message.prosodyVolume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SynthesizeSpeechConfig>, I>>(base?: I): SynthesizeSpeechConfig {
    return SynthesizeSpeechConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SynthesizeSpeechConfig>, I>>(object: I): SynthesizeSpeechConfig {
    const message = createBaseSynthesizeSpeechConfig();
    message.encoding = object.encoding ?? 0;
    message.sampleRateHz = object.sampleRateHz ?? 0;
    message.voiceName = object.voiceName ?? "";
    message.languageCode = object.languageCode ?? "";
    message.prosodyRate = object.prosodyRate ?? "";
    message.prosodyPitch = object.prosodyPitch ?? "";
    message.prosodyVolume = object.prosodyVolume ?? "";
    return message;
  },
};

function createBaseStreamingTranslateSpeechToSpeechResponse(): StreamingTranslateSpeechToSpeechResponse {
  return { speech: undefined, id: undefined };
}

export const StreamingTranslateSpeechToSpeechResponse = {
  encode(message: StreamingTranslateSpeechToSpeechResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.speech !== undefined) {
      SynthesizeSpeechResponse.encode(message.speech, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToSpeechResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToSpeechResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.speech = SynthesizeSpeechResponse.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToSpeechResponse {
    return {
      speech: isSet(object.speech) ? SynthesizeSpeechResponse.fromJSON(object.speech) : undefined,
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToSpeechResponse): unknown {
    const obj: any = {};
    if (message.speech !== undefined) {
      obj.speech = SynthesizeSpeechResponse.toJSON(message.speech);
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechResponse>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToSpeechResponse {
    return StreamingTranslateSpeechToSpeechResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToSpeechResponse>, I>>(
    object: I,
  ): StreamingTranslateSpeechToSpeechResponse {
    const message = createBaseStreamingTranslateSpeechToSpeechResponse();
    message.speech = (object.speech !== undefined && object.speech !== null)
      ? SynthesizeSpeechResponse.fromPartial(object.speech)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseStreamingTranslateSpeechToTextRequest(): StreamingTranslateSpeechToTextRequest {
  return { config: undefined, audioContent: undefined, id: undefined };
}

export const StreamingTranslateSpeechToTextRequest = {
  encode(message: StreamingTranslateSpeechToTextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      StreamingTranslateSpeechToTextConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audioContent !== undefined) {
      writer.uint32(18).bytes(message.audioContent);
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToTextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = StreamingTranslateSpeechToTextConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioContent = reader.bytes();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToTextRequest {
    return {
      config: isSet(object.config) ? StreamingTranslateSpeechToTextConfig.fromJSON(object.config) : undefined,
      audioContent: isSet(object.audioContent) ? bytesFromBase64(object.audioContent) : undefined,
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToTextRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = StreamingTranslateSpeechToTextConfig.toJSON(message.config);
    }
    if (message.audioContent !== undefined) {
      obj.audioContent = base64FromBytes(message.audioContent);
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextRequest>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToTextRequest {
    return StreamingTranslateSpeechToTextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextRequest>, I>>(
    object: I,
  ): StreamingTranslateSpeechToTextRequest {
    const message = createBaseStreamingTranslateSpeechToTextRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? StreamingTranslateSpeechToTextConfig.fromPartial(object.config)
      : undefined;
    message.audioContent = object.audioContent ?? undefined;
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseStreamingTranslateSpeechToTextResponse(): StreamingTranslateSpeechToTextResponse {
  return { results: [], id: undefined };
}

export const StreamingTranslateSpeechToTextResponse = {
  encode(message: StreamingTranslateSpeechToTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      StreamingRecognitionResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(StreamingRecognitionResult.decode(reader, reader.uint32()));
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToTextResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => StreamingRecognitionResult.fromJSON(e))
        : [],
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToTextResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => StreamingRecognitionResult.toJSON(e));
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextResponse>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToTextResponse {
    return StreamingTranslateSpeechToTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextResponse>, I>>(
    object: I,
  ): StreamingTranslateSpeechToTextResponse {
    const message = createBaseStreamingTranslateSpeechToTextResponse();
    message.results = object.results?.map((e) => StreamingRecognitionResult.fromPartial(e)) || [];
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseStreamingTranslateSpeechToTextConfig(): StreamingTranslateSpeechToTextConfig {
  return { asrConfig: undefined, translationConfig: undefined };
}

export const StreamingTranslateSpeechToTextConfig = {
  encode(message: StreamingTranslateSpeechToTextConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asrConfig !== undefined) {
      StreamingRecognitionConfig.encode(message.asrConfig, writer.uint32(10).fork()).join();
    }
    if (message.translationConfig !== undefined) {
      TranslationConfig.encode(message.translationConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingTranslateSpeechToTextConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingTranslateSpeechToTextConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asrConfig = StreamingRecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.translationConfig = TranslationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingTranslateSpeechToTextConfig {
    return {
      asrConfig: isSet(object.asrConfig) ? StreamingRecognitionConfig.fromJSON(object.asrConfig) : undefined,
      translationConfig: isSet(object.translationConfig)
        ? TranslationConfig.fromJSON(object.translationConfig)
        : undefined,
    };
  },

  toJSON(message: StreamingTranslateSpeechToTextConfig): unknown {
    const obj: any = {};
    if (message.asrConfig !== undefined) {
      obj.asrConfig = StreamingRecognitionConfig.toJSON(message.asrConfig);
    }
    if (message.translationConfig !== undefined) {
      obj.translationConfig = TranslationConfig.toJSON(message.translationConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextConfig>, I>>(
    base?: I,
  ): StreamingTranslateSpeechToTextConfig {
    return StreamingTranslateSpeechToTextConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingTranslateSpeechToTextConfig>, I>>(
    object: I,
  ): StreamingTranslateSpeechToTextConfig {
    const message = createBaseStreamingTranslateSpeechToTextConfig();
    message.asrConfig = (object.asrConfig !== undefined && object.asrConfig !== null)
      ? StreamingRecognitionConfig.fromPartial(object.asrConfig)
      : undefined;
    message.translationConfig = (object.translationConfig !== undefined && object.translationConfig !== null)
      ? TranslationConfig.fromPartial(object.translationConfig)
      : undefined;
    return message;
  },
};

function createBaseTranslateTextRequest(): TranslateTextRequest {
  return { texts: [], model: "", sourceLanguage: "", targetLanguage: "", id: undefined };
}

export const TranslateTextRequest = {
  encode(message: TranslateTextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.texts) {
      writer.uint32(10).string(v!);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.sourceLanguage !== "") {
      writer.uint32(26).string(message.sourceLanguage);
    }
    if (message.targetLanguage !== "") {
      writer.uint32(34).string(message.targetLanguage);
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.texts.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceLanguage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetLanguage = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextRequest {
    return {
      texts: globalThis.Array.isArray(object?.texts) ? object.texts.map((e: any) => globalThis.String(e)) : [],
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      sourceLanguage: isSet(object.sourceLanguage) ? globalThis.String(object.sourceLanguage) : "",
      targetLanguage: isSet(object.targetLanguage) ? globalThis.String(object.targetLanguage) : "",
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: TranslateTextRequest): unknown {
    const obj: any = {};
    if (message.texts?.length) {
      obj.texts = message.texts;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.sourceLanguage !== "") {
      obj.sourceLanguage = message.sourceLanguage;
    }
    if (message.targetLanguage !== "") {
      obj.targetLanguage = message.targetLanguage;
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranslateTextRequest>, I>>(base?: I): TranslateTextRequest {
    return TranslateTextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranslateTextRequest>, I>>(object: I): TranslateTextRequest {
    const message = createBaseTranslateTextRequest();
    message.texts = object.texts?.map((e) => e) || [];
    message.model = object.model ?? "";
    message.sourceLanguage = object.sourceLanguage ?? "";
    message.targetLanguage = object.targetLanguage ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseTranslation(): Translation {
  return { text: "", language: "" };
}

export const Translation = {
  encode(message: Translation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Translation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Translation {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: Translation): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Translation>, I>>(base?: I): Translation {
    return Translation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Translation>, I>>(object: I): Translation {
    const message = createBaseTranslation();
    message.text = object.text ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseTranslateTextResponse(): TranslateTextResponse {
  return { translations: [], id: undefined };
}

export const TranslateTextResponse = {
  encode(message: TranslateTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.translations) {
      Translation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      RequestId.encode(message.id, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translations.push(Translation.decode(reader, reader.uint32()));
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.id = RequestId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextResponse {
    return {
      translations: globalThis.Array.isArray(object?.translations)
        ? object.translations.map((e: any) => Translation.fromJSON(e))
        : [],
      id: isSet(object.id) ? RequestId.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: TranslateTextResponse): unknown {
    const obj: any = {};
    if (message.translations?.length) {
      obj.translations = message.translations.map((e) => Translation.toJSON(e));
    }
    if (message.id !== undefined) {
      obj.id = RequestId.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranslateTextResponse>, I>>(base?: I): TranslateTextResponse {
    return TranslateTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranslateTextResponse>, I>>(object: I): TranslateTextResponse {
    const message = createBaseTranslateTextResponse();
    message.translations = object.translations?.map((e) => Translation.fromPartial(e)) || [];
    message.id = (object.id !== undefined && object.id !== null) ? RequestId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseAvailableLanguageRequest(): AvailableLanguageRequest {
  return { model: "" };
}

export const AvailableLanguageRequest = {
  encode(message: AvailableLanguageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableLanguageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableLanguageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableLanguageRequest {
    return { model: isSet(object.model) ? globalThis.String(object.model) : "" };
  },

  toJSON(message: AvailableLanguageRequest): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvailableLanguageRequest>, I>>(base?: I): AvailableLanguageRequest {
    return AvailableLanguageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvailableLanguageRequest>, I>>(object: I): AvailableLanguageRequest {
    const message = createBaseAvailableLanguageRequest();
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseAvailableLanguageResponse(): AvailableLanguageResponse {
  return { languages: {} };
}

export const AvailableLanguageResponse = {
  encode(message: AvailableLanguageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.languages).forEach(([key, value]) => {
      AvailableLanguageResponse_LanguagesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableLanguageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableLanguageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AvailableLanguageResponse_LanguagesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.languages[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableLanguageResponse {
    return {
      languages: isObject(object.languages)
        ? Object.entries(object.languages).reduce<{ [key: string]: AvailableLanguageResponse_LanguagePair }>(
          (acc, [key, value]) => {
            acc[key] = AvailableLanguageResponse_LanguagePair.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: AvailableLanguageResponse): unknown {
    const obj: any = {};
    if (message.languages) {
      const entries = Object.entries(message.languages);
      if (entries.length > 0) {
        obj.languages = {};
        entries.forEach(([k, v]) => {
          obj.languages[k] = AvailableLanguageResponse_LanguagePair.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvailableLanguageResponse>, I>>(base?: I): AvailableLanguageResponse {
    return AvailableLanguageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvailableLanguageResponse>, I>>(object: I): AvailableLanguageResponse {
    const message = createBaseAvailableLanguageResponse();
    message.languages = Object.entries(object.languages ?? {}).reduce<
      { [key: string]: AvailableLanguageResponse_LanguagePair }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AvailableLanguageResponse_LanguagePair.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAvailableLanguageResponse_LanguagePair(): AvailableLanguageResponse_LanguagePair {
  return { srcLang: [], tgtLang: [] };
}

export const AvailableLanguageResponse_LanguagePair = {
  encode(message: AvailableLanguageResponse_LanguagePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.srcLang) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.tgtLang) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableLanguageResponse_LanguagePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableLanguageResponse_LanguagePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.srcLang.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tgtLang.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableLanguageResponse_LanguagePair {
    return {
      srcLang: globalThis.Array.isArray(object?.srcLang) ? object.srcLang.map((e: any) => globalThis.String(e)) : [],
      tgtLang: globalThis.Array.isArray(object?.tgtLang) ? object.tgtLang.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AvailableLanguageResponse_LanguagePair): unknown {
    const obj: any = {};
    if (message.srcLang?.length) {
      obj.srcLang = message.srcLang;
    }
    if (message.tgtLang?.length) {
      obj.tgtLang = message.tgtLang;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvailableLanguageResponse_LanguagePair>, I>>(
    base?: I,
  ): AvailableLanguageResponse_LanguagePair {
    return AvailableLanguageResponse_LanguagePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvailableLanguageResponse_LanguagePair>, I>>(
    object: I,
  ): AvailableLanguageResponse_LanguagePair {
    const message = createBaseAvailableLanguageResponse_LanguagePair();
    message.srcLang = object.srcLang?.map((e) => e) || [];
    message.tgtLang = object.tgtLang?.map((e) => e) || [];
    return message;
  },
};

function createBaseAvailableLanguageResponse_LanguagesEntry(): AvailableLanguageResponse_LanguagesEntry {
  return { key: "", value: undefined };
}

export const AvailableLanguageResponse_LanguagesEntry = {
  encode(message: AvailableLanguageResponse_LanguagesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AvailableLanguageResponse_LanguagePair.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableLanguageResponse_LanguagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableLanguageResponse_LanguagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AvailableLanguageResponse_LanguagePair.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableLanguageResponse_LanguagesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AvailableLanguageResponse_LanguagePair.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AvailableLanguageResponse_LanguagesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AvailableLanguageResponse_LanguagePair.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvailableLanguageResponse_LanguagesEntry>, I>>(
    base?: I,
  ): AvailableLanguageResponse_LanguagesEntry {
    return AvailableLanguageResponse_LanguagesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvailableLanguageResponse_LanguagesEntry>, I>>(
    object: I,
  ): AvailableLanguageResponse_LanguagesEntry {
    const message = createBaseAvailableLanguageResponse_LanguagesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AvailableLanguageResponse_LanguagePair.fromPartial(object.value)
      : undefined;
    return message;
  },
};

/** RivaTranslation service provides rpcs to translate between languages. */
export type RivaTranslationService = typeof RivaTranslationService;
export const RivaTranslationService = {
  /**
   * Translate text to text, from a source to a target language.  Currently
   * source and target language fields is required, along with the model name.
   * Multiple texts may be passed per request up to the given batch size for the
   * model, which is set at translation pipeline creation time.
   */
  translateText: {
    path: "/nvidia.riva.nmt.RivaTranslation/TranslateText",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TranslateTextRequest) => Buffer.from(TranslateTextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TranslateTextRequest.decode(value),
    responseSerialize: (value: TranslateTextResponse) => Buffer.from(TranslateTextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TranslateTextResponse.decode(value),
  },
  /**
   * Lists the available language pairs and models names to be used for
   * TranslateText
   */
  listSupportedLanguagePairs: {
    path: "/nvidia.riva.nmt.RivaTranslation/ListSupportedLanguagePairs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AvailableLanguageRequest) => Buffer.from(AvailableLanguageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AvailableLanguageRequest.decode(value),
    responseSerialize: (value: AvailableLanguageResponse) =>
      Buffer.from(AvailableLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AvailableLanguageResponse.decode(value),
  },
  /** streaming speech to text translation api. */
  streamingTranslateSpeechToText: {
    path: "/nvidia.riva.nmt.RivaTranslation/StreamingTranslateSpeechToText",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: StreamingTranslateSpeechToTextRequest) =>
      Buffer.from(StreamingTranslateSpeechToTextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StreamingTranslateSpeechToTextRequest.decode(value),
    responseSerialize: (value: StreamingTranslateSpeechToTextResponse) =>
      Buffer.from(StreamingTranslateSpeechToTextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamingTranslateSpeechToTextResponse.decode(value),
  },
  streamingTranslateSpeechToSpeech: {
    path: "/nvidia.riva.nmt.RivaTranslation/StreamingTranslateSpeechToSpeech",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: StreamingTranslateSpeechToSpeechRequest) =>
      Buffer.from(StreamingTranslateSpeechToSpeechRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StreamingTranslateSpeechToSpeechRequest.decode(value),
    responseSerialize: (value: StreamingTranslateSpeechToSpeechResponse) =>
      Buffer.from(StreamingTranslateSpeechToSpeechResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamingTranslateSpeechToSpeechResponse.decode(value),
  },
} as const;

export interface RivaTranslationServer extends UntypedServiceImplementation {
  /**
   * Translate text to text, from a source to a target language.  Currently
   * source and target language fields is required, along with the model name.
   * Multiple texts may be passed per request up to the given batch size for the
   * model, which is set at translation pipeline creation time.
   */
  translateText: handleUnaryCall<TranslateTextRequest, TranslateTextResponse>;
  /**
   * Lists the available language pairs and models names to be used for
   * TranslateText
   */
  listSupportedLanguagePairs: handleUnaryCall<AvailableLanguageRequest, AvailableLanguageResponse>;
  /** streaming speech to text translation api. */
  streamingTranslateSpeechToText: handleBidiStreamingCall<
    StreamingTranslateSpeechToTextRequest,
    StreamingTranslateSpeechToTextResponse
  >;
  streamingTranslateSpeechToSpeech: handleBidiStreamingCall<
    StreamingTranslateSpeechToSpeechRequest,
    StreamingTranslateSpeechToSpeechResponse
  >;
}

export interface RivaTranslationClient extends Client {
  /**
   * Translate text to text, from a source to a target language.  Currently
   * source and target language fields is required, along with the model name.
   * Multiple texts may be passed per request up to the given batch size for the
   * model, which is set at translation pipeline creation time.
   */
  translateText(
    request: TranslateTextRequest,
    callback: (error: ServiceError | null, response: TranslateTextResponse) => void,
  ): ClientUnaryCall;
  translateText(
    request: TranslateTextRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TranslateTextResponse) => void,
  ): ClientUnaryCall;
  translateText(
    request: TranslateTextRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TranslateTextResponse) => void,
  ): ClientUnaryCall;
  /**
   * Lists the available language pairs and models names to be used for
   * TranslateText
   */
  listSupportedLanguagePairs(
    request: AvailableLanguageRequest,
    callback: (error: ServiceError | null, response: AvailableLanguageResponse) => void,
  ): ClientUnaryCall;
  listSupportedLanguagePairs(
    request: AvailableLanguageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AvailableLanguageResponse) => void,
  ): ClientUnaryCall;
  listSupportedLanguagePairs(
    request: AvailableLanguageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AvailableLanguageResponse) => void,
  ): ClientUnaryCall;
  /** streaming speech to text translation api. */
  streamingTranslateSpeechToText(): ClientDuplexStream<
    StreamingTranslateSpeechToTextRequest,
    StreamingTranslateSpeechToTextResponse
  >;
  streamingTranslateSpeechToText(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<StreamingTranslateSpeechToTextRequest, StreamingTranslateSpeechToTextResponse>;
  streamingTranslateSpeechToText(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<StreamingTranslateSpeechToTextRequest, StreamingTranslateSpeechToTextResponse>;
  streamingTranslateSpeechToSpeech(): ClientDuplexStream<
    StreamingTranslateSpeechToSpeechRequest,
    StreamingTranslateSpeechToSpeechResponse
  >;
  streamingTranslateSpeechToSpeech(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<StreamingTranslateSpeechToSpeechRequest, StreamingTranslateSpeechToSpeechResponse>;
  streamingTranslateSpeechToSpeech(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<StreamingTranslateSpeechToSpeechRequest, StreamingTranslateSpeechToSpeechResponse>;
}

export const RivaTranslationClient = makeGenericClientConstructor(
  RivaTranslationService,
  "nvidia.riva.nmt.RivaTranslation",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RivaTranslationClient;
  service: typeof RivaTranslationService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
