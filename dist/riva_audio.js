"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.28.0
// source: riva/proto/riva_audio.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.audioEncodingToJSON = exports.audioEncodingFromJSON = exports.AudioEncoding = exports.protobufPackage = void 0;
/* eslint-disable */
exports.protobufPackage = "nvidia.riva";
/**
 * AudioEncoding specifies the encoding of the audio bytes in the encapsulating
 * message.
 */
var AudioEncoding;
(function (AudioEncoding) {
    /** ENCODING_UNSPECIFIED - Not specified. */
    AudioEncoding[AudioEncoding["ENCODING_UNSPECIFIED"] = 0] = "ENCODING_UNSPECIFIED";
    /** LINEAR_PCM - Uncompressed 16-bit signed little-endian samples (Linear PCM). */
    AudioEncoding[AudioEncoding["LINEAR_PCM"] = 1] = "LINEAR_PCM";
    /**
     * FLAC - `FLAC` (Free Lossless Audio
     * Codec) is the recommended encoding because it is
     * lossless--therefore recognition is not compromised--and
     * requires only about half the bandwidth of `LINEAR16`. `FLAC` stream
     * encoding supports 16-bit and 24-bit samples, however, not all fields in
     * `STREAMINFO` are supported.
     */
    AudioEncoding[AudioEncoding["FLAC"] = 2] = "FLAC";
    /** MULAW - 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law. */
    AudioEncoding[AudioEncoding["MULAW"] = 3] = "MULAW";
    AudioEncoding[AudioEncoding["OGGOPUS"] = 4] = "OGGOPUS";
    /** ALAW - 8-bit samples that compand 13-bit audio samples using G.711 PCMU/a-law. */
    AudioEncoding[AudioEncoding["ALAW"] = 20] = "ALAW";
    AudioEncoding[AudioEncoding["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AudioEncoding || (exports.AudioEncoding = AudioEncoding = {}));
function audioEncodingFromJSON(object) {
    switch (object) {
        case 0:
        case "ENCODING_UNSPECIFIED":
            return AudioEncoding.ENCODING_UNSPECIFIED;
        case 1:
        case "LINEAR_PCM":
            return AudioEncoding.LINEAR_PCM;
        case 2:
        case "FLAC":
            return AudioEncoding.FLAC;
        case 3:
        case "MULAW":
            return AudioEncoding.MULAW;
        case 4:
        case "OGGOPUS":
            return AudioEncoding.OGGOPUS;
        case 20:
        case "ALAW":
            return AudioEncoding.ALAW;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AudioEncoding.UNRECOGNIZED;
    }
}
exports.audioEncodingFromJSON = audioEncodingFromJSON;
function audioEncodingToJSON(object) {
    switch (object) {
        case AudioEncoding.ENCODING_UNSPECIFIED:
            return "ENCODING_UNSPECIFIED";
        case AudioEncoding.LINEAR_PCM:
            return "LINEAR_PCM";
        case AudioEncoding.FLAC:
            return "FLAC";
        case AudioEncoding.MULAW:
            return "MULAW";
        case AudioEncoding.OGGOPUS:
            return "OGGOPUS";
        case AudioEncoding.ALAW:
            return "ALAW";
        case AudioEncoding.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.audioEncodingToJSON = audioEncodingToJSON;
