"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.2
//   protoc               v5.28.0
// source: riva/proto/riva_nmt.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.RivaTranslationClient = exports.RivaTranslationService = exports.AvailableLanguageResponse_LanguagesEntry = exports.AvailableLanguageResponse_LanguagePair = exports.AvailableLanguageResponse = exports.AvailableLanguageRequest = exports.TranslateTextResponse = exports.Translation = exports.TranslateTextRequest = exports.StreamingTranslateSpeechToTextConfig = exports.StreamingTranslateSpeechToTextResponse = exports.StreamingTranslateSpeechToTextRequest = exports.StreamingTranslateSpeechToSpeechResponse = exports.SynthesizeSpeechConfig = exports.TranslationConfig = exports.StreamingTranslateSpeechToSpeechRequest = exports.StreamingTranslateSpeechToSpeechConfig = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const grpc_js_1 = require("@grpc/grpc-js");
const riva_asr_1 = require("./riva_asr");
const riva_audio_1 = require("./riva_audio");
const riva_common_1 = require("./riva_common");
const riva_tts_1 = require("./riva_tts");
exports.protobufPackage = "nvidia.riva.nmt";
function createBaseStreamingTranslateSpeechToSpeechConfig() {
    return { asrConfig: undefined, ttsConfig: undefined, translationConfig: undefined };
}
exports.StreamingTranslateSpeechToSpeechConfig = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.asrConfig !== undefined) {
            riva_asr_1.StreamingRecognitionConfig.encode(message.asrConfig, writer.uint32(10).fork()).join();
        }
        if (message.ttsConfig !== undefined) {
            exports.SynthesizeSpeechConfig.encode(message.ttsConfig, writer.uint32(18).fork()).join();
        }
        if (message.translationConfig !== undefined) {
            exports.TranslationConfig.encode(message.translationConfig, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToSpeechConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.asrConfig = riva_asr_1.StreamingRecognitionConfig.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ttsConfig = exports.SynthesizeSpeechConfig.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.translationConfig = exports.TranslationConfig.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            asrConfig: isSet(object.asrConfig) ? riva_asr_1.StreamingRecognitionConfig.fromJSON(object.asrConfig) : undefined,
            ttsConfig: isSet(object.ttsConfig) ? exports.SynthesizeSpeechConfig.fromJSON(object.ttsConfig) : undefined,
            translationConfig: isSet(object.translationConfig)
                ? exports.TranslationConfig.fromJSON(object.translationConfig)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.asrConfig !== undefined) {
            obj.asrConfig = riva_asr_1.StreamingRecognitionConfig.toJSON(message.asrConfig);
        }
        if (message.ttsConfig !== undefined) {
            obj.ttsConfig = exports.SynthesizeSpeechConfig.toJSON(message.ttsConfig);
        }
        if (message.translationConfig !== undefined) {
            obj.translationConfig = exports.TranslationConfig.toJSON(message.translationConfig);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToSpeechConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseStreamingTranslateSpeechToSpeechConfig();
        message.asrConfig = (object.asrConfig !== undefined && object.asrConfig !== null)
            ? riva_asr_1.StreamingRecognitionConfig.fromPartial(object.asrConfig)
            : undefined;
        message.ttsConfig = (object.ttsConfig !== undefined && object.ttsConfig !== null)
            ? exports.SynthesizeSpeechConfig.fromPartial(object.ttsConfig)
            : undefined;
        message.translationConfig = (object.translationConfig !== undefined && object.translationConfig !== null)
            ? exports.TranslationConfig.fromPartial(object.translationConfig)
            : undefined;
        return message;
    },
};
function createBaseStreamingTranslateSpeechToSpeechRequest() {
    return { config: undefined, audioContent: undefined, id: undefined };
}
exports.StreamingTranslateSpeechToSpeechRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.config !== undefined) {
            exports.StreamingTranslateSpeechToSpeechConfig.encode(message.config, writer.uint32(10).fork()).join();
        }
        if (message.audioContent !== undefined) {
            writer.uint32(18).bytes(message.audioContent);
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToSpeechRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.config = exports.StreamingTranslateSpeechToSpeechConfig.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.audioContent = reader.bytes();
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            config: isSet(object.config) ? exports.StreamingTranslateSpeechToSpeechConfig.fromJSON(object.config) : undefined,
            audioContent: isSet(object.audioContent) ? bytesFromBase64(object.audioContent) : undefined,
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = exports.StreamingTranslateSpeechToSpeechConfig.toJSON(message.config);
        }
        if (message.audioContent !== undefined) {
            obj.audioContent = base64FromBytes(message.audioContent);
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToSpeechRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStreamingTranslateSpeechToSpeechRequest();
        message.config = (object.config !== undefined && object.config !== null)
            ? exports.StreamingTranslateSpeechToSpeechConfig.fromPartial(object.config)
            : undefined;
        message.audioContent = (_a = object.audioContent) !== null && _a !== void 0 ? _a : undefined;
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseTranslationConfig() {
    return { sourceLanguageCode: "", targetLanguageCode: "", modelName: "" };
}
exports.TranslationConfig = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sourceLanguageCode !== "") {
            writer.uint32(10).string(message.sourceLanguageCode);
        }
        if (message.targetLanguageCode !== "") {
            writer.uint32(18).string(message.targetLanguageCode);
        }
        if (message.modelName !== "") {
            writer.uint32(26).string(message.modelName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranslationConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sourceLanguageCode = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.targetLanguageCode = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.modelName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
            targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
            modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sourceLanguageCode !== "") {
            obj.sourceLanguageCode = message.sourceLanguageCode;
        }
        if (message.targetLanguageCode !== "") {
            obj.targetLanguageCode = message.targetLanguageCode;
        }
        if (message.modelName !== "") {
            obj.modelName = message.modelName;
        }
        return obj;
    },
    create(base) {
        return exports.TranslationConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTranslationConfig();
        message.sourceLanguageCode = (_a = object.sourceLanguageCode) !== null && _a !== void 0 ? _a : "";
        message.targetLanguageCode = (_b = object.targetLanguageCode) !== null && _b !== void 0 ? _b : "";
        message.modelName = (_c = object.modelName) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseSynthesizeSpeechConfig() {
    return {
        encoding: 0,
        sampleRateHz: 0,
        voiceName: "",
        languageCode: "",
        prosodyRate: "",
        prosodyPitch: "",
        prosodyVolume: "",
    };
}
exports.SynthesizeSpeechConfig = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.encoding !== 0) {
            writer.uint32(8).int32(message.encoding);
        }
        if (message.sampleRateHz !== 0) {
            writer.uint32(16).int32(message.sampleRateHz);
        }
        if (message.voiceName !== "") {
            writer.uint32(26).string(message.voiceName);
        }
        if (message.languageCode !== "") {
            writer.uint32(34).string(message.languageCode);
        }
        if (message.prosodyRate !== "") {
            writer.uint32(42).string(message.prosodyRate);
        }
        if (message.prosodyPitch !== "") {
            writer.uint32(50).string(message.prosodyPitch);
        }
        if (message.prosodyVolume !== "") {
            writer.uint32(58).string(message.prosodyVolume);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSynthesizeSpeechConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.encoding = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.sampleRateHz = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.voiceName = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.languageCode = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.prosodyRate = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.prosodyPitch = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.prosodyVolume = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            encoding: isSet(object.encoding) ? (0, riva_audio_1.audioEncodingFromJSON)(object.encoding) : 0,
            sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
            voiceName: isSet(object.voiceName) ? globalThis.String(object.voiceName) : "",
            languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
            prosodyRate: isSet(object.prosodyRate) ? globalThis.String(object.prosodyRate) : "",
            prosodyPitch: isSet(object.prosodyPitch) ? globalThis.String(object.prosodyPitch) : "",
            prosodyVolume: isSet(object.prosodyVolume) ? globalThis.String(object.prosodyVolume) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.encoding !== 0) {
            obj.encoding = (0, riva_audio_1.audioEncodingToJSON)(message.encoding);
        }
        if (message.sampleRateHz !== 0) {
            obj.sampleRateHz = Math.round(message.sampleRateHz);
        }
        if (message.voiceName !== "") {
            obj.voiceName = message.voiceName;
        }
        if (message.languageCode !== "") {
            obj.languageCode = message.languageCode;
        }
        if (message.prosodyRate !== "") {
            obj.prosodyRate = message.prosodyRate;
        }
        if (message.prosodyPitch !== "") {
            obj.prosodyPitch = message.prosodyPitch;
        }
        if (message.prosodyVolume !== "") {
            obj.prosodyVolume = message.prosodyVolume;
        }
        return obj;
    },
    create(base) {
        return exports.SynthesizeSpeechConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseSynthesizeSpeechConfig();
        message.encoding = (_a = object.encoding) !== null && _a !== void 0 ? _a : 0;
        message.sampleRateHz = (_b = object.sampleRateHz) !== null && _b !== void 0 ? _b : 0;
        message.voiceName = (_c = object.voiceName) !== null && _c !== void 0 ? _c : "";
        message.languageCode = (_d = object.languageCode) !== null && _d !== void 0 ? _d : "";
        message.prosodyRate = (_e = object.prosodyRate) !== null && _e !== void 0 ? _e : "";
        message.prosodyPitch = (_f = object.prosodyPitch) !== null && _f !== void 0 ? _f : "";
        message.prosodyVolume = (_g = object.prosodyVolume) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseStreamingTranslateSpeechToSpeechResponse() {
    return { speech: undefined, id: undefined };
}
exports.StreamingTranslateSpeechToSpeechResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.speech !== undefined) {
            riva_tts_1.SynthesizeSpeechResponse.encode(message.speech, writer.uint32(10).fork()).join();
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToSpeechResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.speech = riva_tts_1.SynthesizeSpeechResponse.decode(reader, reader.uint32());
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            speech: isSet(object.speech) ? riva_tts_1.SynthesizeSpeechResponse.fromJSON(object.speech) : undefined,
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.speech !== undefined) {
            obj.speech = riva_tts_1.SynthesizeSpeechResponse.toJSON(message.speech);
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToSpeechResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseStreamingTranslateSpeechToSpeechResponse();
        message.speech = (object.speech !== undefined && object.speech !== null)
            ? riva_tts_1.SynthesizeSpeechResponse.fromPartial(object.speech)
            : undefined;
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseStreamingTranslateSpeechToTextRequest() {
    return { config: undefined, audioContent: undefined, id: undefined };
}
exports.StreamingTranslateSpeechToTextRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.config !== undefined) {
            exports.StreamingTranslateSpeechToTextConfig.encode(message.config, writer.uint32(10).fork()).join();
        }
        if (message.audioContent !== undefined) {
            writer.uint32(18).bytes(message.audioContent);
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToTextRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.config = exports.StreamingTranslateSpeechToTextConfig.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.audioContent = reader.bytes();
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            config: isSet(object.config) ? exports.StreamingTranslateSpeechToTextConfig.fromJSON(object.config) : undefined,
            audioContent: isSet(object.audioContent) ? bytesFromBase64(object.audioContent) : undefined,
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = exports.StreamingTranslateSpeechToTextConfig.toJSON(message.config);
        }
        if (message.audioContent !== undefined) {
            obj.audioContent = base64FromBytes(message.audioContent);
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToTextRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStreamingTranslateSpeechToTextRequest();
        message.config = (object.config !== undefined && object.config !== null)
            ? exports.StreamingTranslateSpeechToTextConfig.fromPartial(object.config)
            : undefined;
        message.audioContent = (_a = object.audioContent) !== null && _a !== void 0 ? _a : undefined;
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseStreamingTranslateSpeechToTextResponse() {
    return { results: [], id: undefined };
}
exports.StreamingTranslateSpeechToTextResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.results) {
            riva_asr_1.StreamingRecognitionResult.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToTextResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(riva_asr_1.StreamingRecognitionResult.decode(reader, reader.uint32()));
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.results)
                ? object.results.map((e) => riva_asr_1.StreamingRecognitionResult.fromJSON(e))
                : [],
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.results) === null || _a === void 0 ? void 0 : _a.length) {
            obj.results = message.results.map((e) => riva_asr_1.StreamingRecognitionResult.toJSON(e));
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToTextResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStreamingTranslateSpeechToTextResponse();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => riva_asr_1.StreamingRecognitionResult.fromPartial(e))) || [];
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseStreamingTranslateSpeechToTextConfig() {
    return { asrConfig: undefined, translationConfig: undefined };
}
exports.StreamingTranslateSpeechToTextConfig = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.asrConfig !== undefined) {
            riva_asr_1.StreamingRecognitionConfig.encode(message.asrConfig, writer.uint32(10).fork()).join();
        }
        if (message.translationConfig !== undefined) {
            exports.TranslationConfig.encode(message.translationConfig, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamingTranslateSpeechToTextConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.asrConfig = riva_asr_1.StreamingRecognitionConfig.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.translationConfig = exports.TranslationConfig.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            asrConfig: isSet(object.asrConfig) ? riva_asr_1.StreamingRecognitionConfig.fromJSON(object.asrConfig) : undefined,
            translationConfig: isSet(object.translationConfig)
                ? exports.TranslationConfig.fromJSON(object.translationConfig)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.asrConfig !== undefined) {
            obj.asrConfig = riva_asr_1.StreamingRecognitionConfig.toJSON(message.asrConfig);
        }
        if (message.translationConfig !== undefined) {
            obj.translationConfig = exports.TranslationConfig.toJSON(message.translationConfig);
        }
        return obj;
    },
    create(base) {
        return exports.StreamingTranslateSpeechToTextConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseStreamingTranslateSpeechToTextConfig();
        message.asrConfig = (object.asrConfig !== undefined && object.asrConfig !== null)
            ? riva_asr_1.StreamingRecognitionConfig.fromPartial(object.asrConfig)
            : undefined;
        message.translationConfig = (object.translationConfig !== undefined && object.translationConfig !== null)
            ? exports.TranslationConfig.fromPartial(object.translationConfig)
            : undefined;
        return message;
    },
};
function createBaseTranslateTextRequest() {
    return { texts: [], model: "", sourceLanguage: "", targetLanguage: "", id: undefined };
}
exports.TranslateTextRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.texts) {
            writer.uint32(10).string(v);
        }
        if (message.model !== "") {
            writer.uint32(18).string(message.model);
        }
        if (message.sourceLanguage !== "") {
            writer.uint32(26).string(message.sourceLanguage);
        }
        if (message.targetLanguage !== "") {
            writer.uint32(34).string(message.targetLanguage);
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranslateTextRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.texts.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.model = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sourceLanguage = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.targetLanguage = reader.string();
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            texts: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.texts) ? object.texts.map((e) => globalThis.String(e)) : [],
            model: isSet(object.model) ? globalThis.String(object.model) : "",
            sourceLanguage: isSet(object.sourceLanguage) ? globalThis.String(object.sourceLanguage) : "",
            targetLanguage: isSet(object.targetLanguage) ? globalThis.String(object.targetLanguage) : "",
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.texts) === null || _a === void 0 ? void 0 : _a.length) {
            obj.texts = message.texts;
        }
        if (message.model !== "") {
            obj.model = message.model;
        }
        if (message.sourceLanguage !== "") {
            obj.sourceLanguage = message.sourceLanguage;
        }
        if (message.targetLanguage !== "") {
            obj.targetLanguage = message.targetLanguage;
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.TranslateTextRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTranslateTextRequest();
        message.texts = ((_a = object.texts) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.model = (_b = object.model) !== null && _b !== void 0 ? _b : "";
        message.sourceLanguage = (_c = object.sourceLanguage) !== null && _c !== void 0 ? _c : "";
        message.targetLanguage = (_d = object.targetLanguage) !== null && _d !== void 0 ? _d : "";
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseTranslation() {
    return { text: "", language: "" };
}
exports.Translation = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        if (message.language !== "") {
            writer.uint32(18).string(message.language);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranslation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.language = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? globalThis.String(object.text) : "",
            language: isSet(object.language) ? globalThis.String(object.language) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        if (message.language !== "") {
            obj.language = message.language;
        }
        return obj;
    },
    create(base) {
        return exports.Translation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTranslation();
        message.text = (_a = object.text) !== null && _a !== void 0 ? _a : "";
        message.language = (_b = object.language) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseTranslateTextResponse() {
    return { translations: [], id: undefined };
}
exports.TranslateTextResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.translations) {
            exports.Translation.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.id !== undefined) {
            riva_common_1.RequestId.encode(message.id, writer.uint32(802).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranslateTextResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.translations.push(exports.Translation.decode(reader, reader.uint32()));
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.id = riva_common_1.RequestId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            translations: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.translations)
                ? object.translations.map((e) => exports.Translation.fromJSON(e))
                : [],
            id: isSet(object.id) ? riva_common_1.RequestId.fromJSON(object.id) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.translations) === null || _a === void 0 ? void 0 : _a.length) {
            obj.translations = message.translations.map((e) => exports.Translation.toJSON(e));
        }
        if (message.id !== undefined) {
            obj.id = riva_common_1.RequestId.toJSON(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.TranslateTextResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTranslateTextResponse();
        message.translations = ((_a = object.translations) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Translation.fromPartial(e))) || [];
        message.id = (object.id !== undefined && object.id !== null) ? riva_common_1.RequestId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseAvailableLanguageRequest() {
    return { model: "" };
}
exports.AvailableLanguageRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.model !== "") {
            writer.uint32(10).string(message.model);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAvailableLanguageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.model = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { model: isSet(object.model) ? globalThis.String(object.model) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.model !== "") {
            obj.model = message.model;
        }
        return obj;
    },
    create(base) {
        return exports.AvailableLanguageRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAvailableLanguageRequest();
        message.model = (_a = object.model) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseAvailableLanguageResponse() {
    return { languages: {} };
}
exports.AvailableLanguageResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.languages).forEach(([key, value]) => {
            exports.AvailableLanguageResponse_LanguagesEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAvailableLanguageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.AvailableLanguageResponse_LanguagesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.languages[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            languages: isObject(object.languages)
                ? Object.entries(object.languages).reduce((acc, [key, value]) => {
                    acc[key] = exports.AvailableLanguageResponse_LanguagePair.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.languages) {
            const entries = Object.entries(message.languages);
            if (entries.length > 0) {
                obj.languages = {};
                entries.forEach(([k, v]) => {
                    obj.languages[k] = exports.AvailableLanguageResponse_LanguagePair.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.AvailableLanguageResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAvailableLanguageResponse();
        message.languages = Object.entries((_a = object.languages) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.AvailableLanguageResponse_LanguagePair.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseAvailableLanguageResponse_LanguagePair() {
    return { srcLang: [], tgtLang: [] };
}
exports.AvailableLanguageResponse_LanguagePair = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.srcLang) {
            writer.uint32(10).string(v);
        }
        for (const v of message.tgtLang) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAvailableLanguageResponse_LanguagePair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.srcLang.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.tgtLang.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            srcLang: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.srcLang) ? object.srcLang.map((e) => globalThis.String(e)) : [],
            tgtLang: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.tgtLang) ? object.tgtLang.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if ((_a = message.srcLang) === null || _a === void 0 ? void 0 : _a.length) {
            obj.srcLang = message.srcLang;
        }
        if ((_b = message.tgtLang) === null || _b === void 0 ? void 0 : _b.length) {
            obj.tgtLang = message.tgtLang;
        }
        return obj;
    },
    create(base) {
        return exports.AvailableLanguageResponse_LanguagePair.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAvailableLanguageResponse_LanguagePair();
        message.srcLang = ((_a = object.srcLang) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.tgtLang = ((_b = object.tgtLang) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseAvailableLanguageResponse_LanguagesEntry() {
    return { key: "", value: undefined };
}
exports.AvailableLanguageResponse_LanguagesEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.AvailableLanguageResponse_LanguagePair.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAvailableLanguageResponse_LanguagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.AvailableLanguageResponse_LanguagePair.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? exports.AvailableLanguageResponse_LanguagePair.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.AvailableLanguageResponse_LanguagePair.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.AvailableLanguageResponse_LanguagesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAvailableLanguageResponse_LanguagesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.AvailableLanguageResponse_LanguagePair.fromPartial(object.value)
            : undefined;
        return message;
    },
};
exports.RivaTranslationService = {
    /**
     * Translate text to text, from a source to a target language.  Currently
     * source and target language fields is required, along with the model name.
     * Multiple texts may be passed per request up to the given batch size for the
     * model, which is set at translation pipeline creation time.
     */
    translateText: {
        path: "/nvidia.riva.nmt.RivaTranslation/TranslateText",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.TranslateTextRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.TranslateTextRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.TranslateTextResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.TranslateTextResponse.decode(value),
    },
    /**
     * Lists the available language pairs and models names to be used for
     * TranslateText
     */
    listSupportedLanguagePairs: {
        path: "/nvidia.riva.nmt.RivaTranslation/ListSupportedLanguagePairs",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.AvailableLanguageRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.AvailableLanguageRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.AvailableLanguageResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.AvailableLanguageResponse.decode(value),
    },
    /** streaming speech to text translation api. */
    streamingTranslateSpeechToText: {
        path: "/nvidia.riva.nmt.RivaTranslation/StreamingTranslateSpeechToText",
        requestStream: true,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(exports.StreamingTranslateSpeechToTextRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.StreamingTranslateSpeechToTextRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.StreamingTranslateSpeechToTextResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.StreamingTranslateSpeechToTextResponse.decode(value),
    },
    streamingTranslateSpeechToSpeech: {
        path: "/nvidia.riva.nmt.RivaTranslation/StreamingTranslateSpeechToSpeech",
        requestStream: true,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(exports.StreamingTranslateSpeechToSpeechRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.StreamingTranslateSpeechToSpeechRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.StreamingTranslateSpeechToSpeechResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.StreamingTranslateSpeechToSpeechResponse.decode(value),
    },
};
exports.RivaTranslationClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.RivaTranslationService, "nvidia.riva.nmt.RivaTranslation");
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
